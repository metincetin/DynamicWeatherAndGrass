// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

#include "BitangentNoise.hlsl"
#include "OpenSimplex2.hlsl"

RWTexture2D<float4> Result;

struct WindManipulationData
{
    float3 Position;
    float Angle;
    float Arc;
    float2 Power;
    float2 Radius;
    float Time;
};

StructuredBuffer<WindManipulationData> _WindManipulationBuffer;

float _NoiseScale;
float _WindChangePower;
float _WindFrequency;
float _Time;
float3 _WindDirection;

void Remap(float In, float2 InMinMax, float2 OutMinMax, out float Out)
{
    Out = OutMinMax.x + (In - InMinMax.x) * (OutMinMax.y - OutMinMax.x) / (InMinMax.y - InMinMax.x);
}

void Remap(float2 In, float2 InMinMax, float2 OutMinMax, out float2 Out)
{
    Out = OutMinMax.x + (In - InMinMax.x) * (OutMinMax.y - OutMinMax.x) / (InMinMax.y - InMinMax.x);
}

void Remap(float3 In, float2 InMinMax, float2 OutMinMax, out float3 Out)
{
    Out = OutMinMax.x + (In - InMinMax.x) * (OutMinMax.y - OutMinMax.x) / (InMinMax.y - InMinMax.x);
}

void Remap(float4 In, float2 InMinMax, float2 OutMinMax, out float4 Out)
{
    Out = OutMinMax.x + (In - InMinMax.x) * (OutMinMax.y - OutMinMax.x) / (InMinMax.y - InMinMax.x);
}

float Falloff(float2 pos, float radius1, float radius2){
	return saturate(length(pos) - radius1 - length(pos) - radius2);
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    const int2 startPos = id.xy * 8;
	const float2 worldSize = float2(-5, 5);

    for (int x = 0; x < 8;x++)
    {
        for (int y = 0; y < 8;y++){
            int2 pos = startPos + int2(x,y);
			float2 pixelPosW;
            Remap(pos, float2(0, 512), worldSize, pixelPosW);

            float2 offset = float2(
                pos.x * _NoiseScale + _Time * _WindFrequency * _WindDirection.x,
                pos.y * _NoiseScale + _Time * _WindFrequency * _WindDirection.z
            );
        

            float3 noisePos = float3(offset.x, offset.y, _Time * _WindChangePower);
            float4 osx = openSimplex2Base(noisePos);
            Remap(osx, worldSize, float2(0,1), osx);
            osx.w = 0;

            for(int i = 0;i<_WindManipulationBuffer.Length;i++)
            {
                WindManipulationData data = _WindManipulationBuffer[i];

				float distW = distance(data.Position.xz, pixelPosW);
                float2 dir = normalize(pixelPosW - data.Position.xz);


				float radius = data.Radius.x * data.Radius.y;
				float radiusN = data.Radius.y / data.Radius.x ;
                float f1 = 1 / (distW * distW);
                float f2 = distW + 1;
				float falloff = saturate(smoothstep(data.Radius.x * 0.5,0,distance(radius, distW)));

                if (distW < radius)
                {
                    float shape = dot(dir, float2(0,1));
                    float d = step(data.Arc, shape);

                    //osx.xy += data.Power.x * data.Power.y * float4(dir, 0, 1) * falloff * d;
                    osx.yw += data.Power.x * (data.Power.y) * dir *  d * falloff ;
                }
            }

            Result[pos] = osx;
        }
    }
}
